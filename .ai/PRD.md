# Product Requirements Document (PRD)

**Overview:** The Astral Protocol API will serve as a unified gateway for accessing **location proof attestations** (EAS attestations) across multiple blockchains. It aims to bridge on-chain location proof data with standard web API interfaces, making it easy for developers and GIS systems to query and integrate this data. The API must support both OGC-compliant RESTful access for geospatial interoperability and a GraphQL interface for flexible queries. The system should be **production-grade, secure, and highly automated**, minimizing ongoing maintenance.

**Objectives and Use Cases:** The API will allow clients to retrieve proofs that a certain event or user was at a given location and time, as recorded on-chain ([Introduction | Astral Documentation](https://docs.astral.global/docs/location-proof-protocol/introduction#:~:text=The%20Location%20Proof%20Protocol%20aims,a%20flexible%2C%20yet%20standardized%20way)). For example, a dApp or service could query all location proofs within a geographic area and time range to verify an attendance or trigger location-based logic. GIS tools should be able to consume the data via OGC API Features (e.g. as GeoJSON), and web or mobile apps should be able to query specific proof details (e.g. by user or event) via GraphQL. Real-time updates will ensure that new proofs and revocations propagate quickly to clients.

**Scope and Requirements:** The API must fulfill the following core requirements: 

- **Multi-Chain Attestation Queries:** Retrieve location proof attestations from all supported networks (initially Arbitrum One, Celo, Ethereum Sepolia, Base mainnet ([EAS Schema | Astral Documentation](https://docs.astral.global/docs/location-proof-protocol/eas-schema#:~:text=The%20current%20working%20schema%20is,deployed%20on)), and easily extensible to others). It should use the standardized EAS schema (UID `0xba4171c9...`) v0.1 deployed on these chains ([EAS Schema | Astral Documentation](https://docs.astral.global/docs/location-proof-protocol/eas-schema#:~:text=the%20v0,across%20all%20chains)). This ensures a uniform data model across chains.
- **Location Proof Data Model:** Each attestation contains structured fields (e.g. eventTimestamp, location, locationType, proof recipe, media, etc.) that must be decoded and stored. The schema includes fields such as `eventTimestamp`, `srs` (spatial reference, e.g. "EPSG:4326"), `locationType` (format of location data), `location` (the location value), `recipeType`/`recipePayload` (proof method data), `mediaType`/`mediaData` (attached media info), and `memo` ([EAS Schema | Astral Documentation](https://docs.astral.global/docs/location-proof-protocol/eas-schema#:~:text=structured.,Specified%20in%20recipe%20definition)) ([EAS Schema | Astral Documentation](https://docs.astral.global/docs/location-proof-protocol/eas-schema#:~:text=definition.%60mediaType%20%60%60string,User%20input)). The API must present these in human-readable formats (e.g. coordinates as numbers, timestamps as ISO strings).
- **Up-to-date Database:** The system should maintain a **database of attestations** that is synchronized with the latest on-chain data. New attestations should appear in the API shortly after they are created on-chain, and if an attestation is revoked or updated (if EAS supports revocations), the change should be reflected. Decoding of attestation data (e.g. splitting coordinate strings into lat/long) should happen before storage so that queries can filter by those values.
- **OGC API – Features Compliance:** Provide a RESTful interface that fully complies with the OGC API Features **Part 1: Core** standard for geospatial features. This includes implementing the required endpoints (landing page, conformance declaration, collections, items, etc.) ([OGC API - Features - OGC API workshop](https://ogcapi-workshop.ogc.org/api-deep-dive/features/#:~:text=Resource%20Method%20Path%20Purpose%20Landing,are%20offered%20through%20the%20API)) and returning geospatial data in standard formats (GeoJSON as default). The API should serve location proofs as **features** in a collection (or multiple collections), enabling GIS clients to query by location and time. Where applicable, support OGC API filtering parameters like `bbox` and `datetime` to constrain queries spatially and temporally ([OGC API - Features - OGC API workshop](https://ogcapi-workshop.ogc.org/api-deep-dive/features/#:~:text=A%20bbox%20or%20datetime%20parameter,net%2Fdar)). This will make the API instantly usable in tools like QGIS, Leaflet, or any OGC-compliant client.
- **GraphQL Proxy (Apollo):** Provide a GraphQL endpoint (using Apollo Server) that exposes the same data for developer-friendly queries. This GraphQL API should allow clients to request exactly the fields they need and join related data (e.g. querying proofs with filtering by prover address or event time in a single request). It will act as a **proxy** or alternate interface to the underlying data, not introducing new data sources. Apollo should be configured for production readiness (proper error handling, security, etc.) ([Introduction to Apollo Server - Apollo GraphQL Docs](https://www.apollographql.com/docs/apollo-server#:~:text=Apollo%20Server%20is%20an%20open,use%20data%20from%20any%20source)).
- **Supabase Integration:** Use Supabase (PostgreSQL) as the primary database and leverage its features for efficiency. All attestation records will be stored in the Supabase DB. Supabase's **Realtime** should be utilized to push updates – for example, new attestation inserts – to subscribed clients ([Realtime | Supabase Docs](https://supabase.com/docs/guides/realtime#:~:text=,send%20them%20to%20authorized%20clients)), enabling live updates in front-ends. Supabase Auth will handle authentication where needed; for instance, if certain write or admin operations are added, we can require a Supabase JWT. The design should consider Row-Level Security policies in Supabase to secure data (though initially data may be public). We should also evaluate Supabase’s built-in REST and GraphQL; however, given custom logic needs (OGC formatting, cross-chain integration), our API will mostly use Supabase as a storage and real-time backplane rather than exposing Supabase’s auto-generated API directly.
- **Automation and DevOps:** The project must be built with **CI/CD**, automated testing, and Infrastructure-as-Code from the start. Developers should be able to spin up the entire stack locally with Docker Compose (API + a local Postgres to simulate Supabase) and run tests easily. The CI pipeline will run tests on each commit and build Docker images for deployment. Infrastructure (like cloud database, or any AWS resources if used) should be codified (using Terraform, Pulumi, or Supabase CLI migrations) for consistency across environments. Deployment to production should be push-button or triggered via the CI (e.g. continuous deployment on the main branch after tests).

**Non-Functional Requirements:** The API should be **scalable and efficient**. Responses must be quick (caching frequent queries where possible) and the system should handle increasing load or data volume. We must keep **operational costs low**, which means using managed services (Supabase) to avoid running our own databases, using serverless or container services that scale down when idle, and writing optimized code/queries. Security is crucial: we must sanitize inputs (especially for GraphQL where clients craft queries), enforce CORS rules for the API, and secure any secrets (API keys, DB creds) via environment variables or secret managers. 

**Out of Scope (for v1):** The initial implementation will focus on read-only access to location proofs. Writing new attestations to the blockchain or heavy on-chain verification logic is out of scope (proving location is handled by external processes and on-chain transactions). Also, advanced OGC features like transactional edits (OGC API Features Part 4) or complex filtering beyond basic spatial/temporal filters may be deferred to future enhancements. However, the architecture should not preclude adding these later.

By meeting these requirements, the Astral Protocol API will provide a **standardized, easy-to-use interface** for verifiable location data on web3, accelerating development of location-based dApps and services while ensuring interoperability with existing geospatial tools.
